<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Todo List Pro</title>
    <link rel="icon" href="https://img.icons8.com/?size=100&id=f9MbZqpEUKcQ&format=png&color=000000" type="image/x-icon">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --primary-color: #007bff;
            --border-color: #dddddd;
            --transition-speed: 0.3s;
            --success-color: #4CAF50;
            --warning-color: #ff9800;
            --danger-color: #f44336;
        }
        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #ffffff;
            --primary-color: #4da3ff;
            --border-color: #444444;
            --success-color: #81c784;
            --warning-color: #ffb74d;
            --danger-color: #e57373;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            transition: background-color var(--transition-speed), color var(--transition-speed), border-color var(--transition-speed);
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            flex: 1;
            width: 100%; /* Ensure container is responsive */
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        .theme-toggle {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.5rem;
            color: var(--text-color);
        }
        .todo-form {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap; /* Allow form elements to wrap on smaller screens */
        }
        .todo-input, .priority-select, .deadline-input {
            flex: 1; /* Allow inputs to grow */
            min-width: 150px; /* Minimum width before wrapping */
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }
         textarea.todo-input {
             min-height: 80px; /* Give textarea some height */
         }
        .add-btn {
            padding: 12px 24px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            flex-shrink: 0; /* Prevent button from shrinking */
        }
        .filter-buttons, .task-counter {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap; /* Allow buttons to wrap */
        }
        .filter-btn, .counter-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
            flex: 1 1 auto; /* Allow buttons to grow and shrink */
            text-align: center;
        }
        .filter-btn.active, .counter-btn.active {
            opacity: 0.9;
            transform: scale(0.98);
        }
        .counter-btn.completed {
            background-color: var(--danger-color);
        }
        .counter-btn.all {
            background-color: var(--success-color);
        }
        .clear-completed-btn {
            margin-top: 20px;
            padding: 10px;
            background-color: var(--danger-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .todo-list {
            list-style: none;
            padding: 0; /* Remove default padding */
        }
        .todo-item {
            display: flex;
            flex-direction: column; /* Stack content vertically */
            padding: 15px;
            margin-bottom: 15px;
            background-color: var(--bg-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            animation: fadeIn 0.5s ease-in;
            position: relative; /* Needed for absolute positioning of message */
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .completed .todo-content,
        .completed .task-description,
        .completed .deadline-info {
            text-decoration: line-through;
            color: var(--border-color);
        }
        .todo-content {
            display: flex;
            align-items: center;
            width: 100%;
            margin-bottom: 10px; /* Space between main content and description/actions */
            flex-wrap: wrap; /* Allow items in todo-content to wrap */
        }
        .todo-text {
            flex: 1; /* Allow text to take available space */
            margin-right: 10px; /* Space between text and countdown/priority */
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            min-width: 0; /* Allow text to shrink below its content size */
        }

        .countdown {
            font-weight: bold;
            color: var(--primary-color);
            margin-right: 10px; /* Space between countdown and priority */
            flex-shrink: 0; /* Prevent countdown from shrinking */
            white-space: nowrap; /* Prevent countdown text from wrapping */
        }
        .overdue .countdown {
            color: var(--danger-color); /* Red for overdue */
        }

        .priority {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            flex-shrink: 0; /* Prevent priority from shrinking */
        }
        .high { background-color: var(--danger-color); color: white; }
        .medium { background-color: var(--warning-color); color: white; }
        .low { background-color: var(--success-color); color: white; }

        .deadline-info {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            color: var(--text-color);
            margin-top: 5px; /* Space below title/countdown/priority */
            flex-wrap: wrap; /* Allow deadline info to wrap */
            width: 100%; /* Take full width */
        }
        .deadline-info strong {
             margin-right: 5px;
        }


        .task-description {
            font-size: 0.9rem;
            color: var(--text-color);
            margin-bottom: 10px; /* Space above actions */
            white-space: pre-wrap; /* Preserve line breaks in description */
            width: 100%; /* Take full width */
        }

        .todo-actions {
            display: flex;
            justify-content: flex-end; /* Align actions to the right */
            width: 100%;
        }
        .action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            margin-left: 10px;
            color: var(--text-color);
            padding: 5px; /* Add padding for easier clicking */
        }

        .task-message {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            z-index: 1; /* Ensure message is above other content */
        }
        .task-message.success {
            background-color: var(--success-color);
            color: white;
        }
        .task-message.warning {
            background-color: var(--warning-color);
            color: white;
        }
        .task-message.danger {
            background-color: var(--danger-color);
            color: white;
        }

        footer {
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
            padding: 15px 0;
            margin-top: 40px;
            border-top: 1px solid var(--border-color);
            width: 100%;
            position: relative;
            bottom: 0;
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            .todo-form {
                flex-direction: column;
            }
            .todo-input, .priority-select, .deadline-input, .add-btn {
                width: 100%;
                min-width: unset; /* Remove min-width on small screens */
            }
            .filter-buttons, .task-counter {
                flex-direction: column; /* Stack buttons vertically */
            }
            .filter-btn, .counter-btn {
                width: 100%;
            }
            .todo-content {
                 flex-direction: column; /* Stack content vertically */
                 align-items: flex-start; /* Align items to the start */
            }
            .todo-text {
                margin-right: 0;
                margin-bottom: 5px; /* Space below title */
                width: 100%; /* Take full width */
                flex: none; /* Remove flex grow/shrink */
            }
            .countdown {
                margin-left: 0;
                margin-bottom: 5px; /* Space below countdown */
                flex-shrink: none;
                white-space: normal; /* Allow wrapping on small screens if needed */
            }
            .priority {
                margin-bottom: 5px; /* Space below priority */
                flex-shrink: none;
            }
             .task-message {
                position: static; /* Position relative to flow on small screens */
                margin-top: 10px;
            }
             .todo-actions {
                justify-content: flex-start; /* Align actions to the left */
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Smart Todo List Pro</h1>
            <button class="theme-toggle" id="themeToggle" aria-label="Toggle dark mode">
                <i class="fas fa-moon"></i>
            </button>
        </div>
        <form class="todo-form" id="todoForm">
            <input type="text" class="todo-input" id="todoInput" placeholder="Add a new task title..." required>
            <textarea class="todo-input" id="todoDescription" placeholder="Add task description (optional)"></textarea>
            <select class="priority-select" id="prioritySelect">
                <option value="low">Low</option>
                <option value="medium">Medium</option>
                <option value="high">High</option>
            </select>
            <input type="datetime-local" class="deadline-input" id="deadlineInput" title="Set task deadline">
            <button type="submit" class="add-btn">Add Task</button>
        </form>
        <div class="task-counter">
            <button class="counter-btn all" id="allCounter">All (<span id="allCount">0</span>)</button>
            <button class="counter-btn high" id="highCounter">High (<span id="highCount">0</span>)</button>
            <button class="counter-btn medium" id="mediumCounter">Medium (<span id="mediumCount">0</span>)</button>
            <button class="counter-btn low" id="lowCounter">Low (<span id="lowCount">0</span>)</button>
            <button class="counter-btn completed" id="completedCounter">Completed (<span id="completedCount">0</span>)</button>
        </div>
        <div class="filter-buttons">
            <button class="filter-btn" data-filter="all">All</button>
            <button class="filter-btn" data-filter="high">High</button>
            <button class="filter-btn" data-filter="medium">Medium</button>
            <button class="filter-btn" data-filter="low">Low</button>
            <button class="filter-btn" data-filter="completed">Completed</button>
        </div>
        <ul class="todo-list" id="todoList"></ul>
        <button class="clear-completed-btn" id="clearCompletedBtn" aria-label="Clear completed tasks">Clear Completed</button>
    </div>
    <footer>
        <p>&copy; 2025 Smart Todo List Pro. All rights reserved.</p>
    </footer>

    <script>
        const todoForm = document.getElementById('todoForm');
        const todoInput = document.getElementById('todoInput');
        const todoDescriptionInput = document.getElementById('todoDescription');
        const todoList = document.getElementById('todoList');
        const prioritySelect = document.getElementById('prioritySelect');
        const deadlineInput = document.getElementById('deadlineInput');
        const themeToggle = document.getElementById('themeToggle');
        const clearCompletedBtn = document.getElementById('clearCompletedBtn');
        const filterButtons = document.querySelectorAll('.filter-btn');
        const counterButtons = document.querySelectorAll('.counter-btn');
        const allCounter = document.getElementById('allCounter');
        const highCounter = document.getElementById('highCounter');
        const mediumCounter = document.getElementById('mediumCounter');
        const lowCounter = document.getElementById('lowCounter');
        const completedCounter = document.getElementById('completedCounter');

        let todos = JSON.parse(localStorage.getItem('todos')) || [];
        let currentTheme = localStorage.getItem('theme') || 'light';
        let currentFilter = 'all';
        const countdownIntervals = {}; // Store intervals for countdowns

        // Initialize theme
        document.documentElement.setAttribute('data-theme', currentTheme);
        themeToggle.innerHTML = currentTheme === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';

        // Request notification permission
        if (Notification.permission !== 'granted' && Notification.permission !== 'denied') {
            Notification.requestPermission();
        }

        function saveTodos() {
            localStorage.setItem('todos', JSON.stringify(todos));
        }

        function updateTaskCounter() {
            const allTasks = todos.length;
            const highTasks = todos.filter(todo => !todo.completed && todo.priority === 'high').length;
            const mediumTasks = todos.filter(todo => !todo.completed && todo.priority === 'medium').length;
            const lowTasks = todos.filter(todo => !todo.completed && todo.priority === 'low').length;
            const completedTasks = todos.filter(todo => todo.completed).length;

            document.getElementById('allCount').textContent = allTasks;
            document.getElementById('highCount').textContent = highTasks;
            document.getElementById('mediumCount').textContent = mediumTasks;
            document.getElementById('lowCount').textContent = lowTasks;
            document.getElementById('completedCount').textContent = completedTasks;

             // Update active states for counters based on current filter
            counterButtons.forEach(btn => {
                btn.classList.remove('active');
                const filter = btn.id.replace('Counter', '').toLowerCase();
                 if (filter === currentFilter || (filter === 'all' && currentFilter === 'all')) {
                    btn.classList.add('active');
                }
            });
        }

        // Updated function to format time difference as "DD days HH:MM:SS"
        function formatTimeDifference(ms) {
            if (ms < 0) return 'Overdue';

            const totalSeconds = Math.floor(ms / 1000);
            const days = Math.floor(totalSeconds / (24 * 60 * 60));
            const hours = Math.floor((totalSeconds % (24 * 60 * 60)) / (60 * 60));
            const minutes = Math.floor((totalSeconds % (60 * 60)) / 60);
            const seconds = totalSeconds % 60;

            const paddedDays = String(days).padStart(2, '0');
            const paddedHours = String(hours).padStart(2, '0');
            const paddedMinutes = String(minutes).padStart(2, '0');
            const paddedSeconds = String(seconds).padStart(2, '0');

            return `${paddedDays} days ${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
        }

        function updateCountdown(todo, countdownElement) {
            const now = new Date();
            const deadline = new Date(todo.deadline);
            const timeDiff = deadline.getTime() - now.getTime();

            countdownElement.textContent = formatTimeDifference(timeDiff);

            if (timeDiff < 0 && !todo.completed) {
                 countdownElement.closest('.todo-item').classList.add('overdue');
                 // Trigger late notification if not already triggered
                 if (!todo.lateNotificationSent) {
                     showNotification(`Task Overdue: "${todo.title}"`, todo.messageTemplates.lateNotification);
                     todo.lateNotificationSent = true; // Mark notification as sent
                     saveTodos(); // Save the updated state
                 }
            } else {
                 countdownElement.closest('.todo-item').classList.remove('overdue');
                 // If task becomes not overdue (e.g., deadline changed or marked incomplete)
                 if (todo.lateNotificationSent) {
                     todo.lateNotificationSent = false; // Reset flag
                     saveTodos();
                 }
            }
        }

        function startCountdown(todo, countdownElement) {
             // Clear existing interval if any
             if (countdownIntervals[todo.id]) {
                 clearInterval(countdownIntervals[todo.id]);
             }

             // Initial update
             updateCountdown(todo, countdownElement);

             // Update every second
             countdownIntervals[todo.id] = setInterval(() => {
                 updateCountdown(todo, countdownElement);
             }, 1000);
        }

        function stopCountdown(todoId) {
             if (countdownIntervals[todoId]) {
                 clearInterval(countdownIntervals[todoId]);
                 delete countdownIntervals[todoId];
             }
        }

        function showNotification(title, body) {
            if (Notification.permission === 'granted') {
                new Notification(title, { body });
            }
        }

        function checkReminders() {
            const now = new Date().getTime();

            todos.forEach(todo => {
                if (todo.deadline && !todo.completed) {
                    const deadlineTime = new Date(todo.deadline).getTime();
                    const timeDiff = deadlineTime - now;

                    // 24-hour reminder
                    const oneDayMs = 24 * 60 * 60 * 1000;
                    // Check if timeDiff is within 24 hours (inclusive) and not already sent
                    if (todo.notificationSettings.reminder24h && timeDiff > 0 && timeDiff <= oneDayMs && !todo.reminder24hSent) {
                         showNotification(`Reminder: "${todo.title}"`, `Just a friendly reminder: "${todo.title}" is due in less than 24 hours!`);
                         todo.reminder24hSent = true;
                         saveTodos();
                    }

                    // Deadline reminder (within the last minute leading up to the deadline)
                    const oneMinuteMs = 60 * 1000;
                     // Check if timeDiff is within the last minute (inclusive) and not already sent
                    if (todo.notificationSettings.reminderDeadline && timeDiff > 0 && timeDiff <= oneMinuteMs && !todo.reminderDeadlineSent) {
                         showNotification(`Deadline Alert: "${todo.title}"`, `Action required! Your task "${todo.title}" is due now.`);
                         todo.reminderDeadlineSent = true;
                         saveTodos();
                    }
                }
            });
        }

        // Check reminders periodically (e.g., every minute)
        setInterval(checkReminders, 60000); // Check every minute

        function renderTodos() {
            // Clear existing countdown intervals before re-rendering
            for (const id in countdownIntervals) {
                 stopCountdown(id);
            }
            todoList.innerHTML = '';

            const filteredTodos = todos.filter(todo => {
                if (currentFilter === 'all') return true;
                if (currentFilter === 'completed') return todo.completed;
                return todo.priority === currentFilter;
            });

            filteredTodos.forEach((todo, index) => {
                const li = document.createElement('li');
                li.className = `todo-item ${todo.completed ? 'completed' : ''}`;
                li.draggable = true;
                li.dataset.id = todo.id; // Use unique ID for drag/drop and identification

                let countdownSpanHTML = '';
                if (todo.deadline) {
                    countdownSpanHTML = `<span class="countdown" data-id="${todo.id}"></span>`;
                }

                let taskMessageHTML = '';
                if (todo.completed) {
                    const completionTime = new Date(todo.completionDate).getTime();
                    const deadlineTime = todo.deadline ? new Date(todo.deadline).getTime() : null;

                    // Show on-time message only if completed on or before the deadline
                    if (todo.deadline && completionTime <= deadlineTime) {
                         taskMessageHTML = `<span class="task-message success">${todo.messageTemplates.onTimeMotivation}</span>`;
                    }
                } else if (todo.deadline && new Date().getTime() > new Date(todo.deadline).getTime()) {
                     // Show overdue message if not completed and deadline is passed
                     taskMessageHTML = `<span class="task-message danger">${todo.messageTemplates.lateNotification}</span>`;
                }


                li.innerHTML = `
                    ${taskMessageHTML}
                    <div class="todo-content">
                        <span class="todo-text">${todo.title}</span>
                        ${countdownSpanHTML} <span class="priority ${todo.priority}">${todo.priority.toUpperCase()}</span>
                    </div>
                    ${todo.description ? `<div class="task-description">${todo.description}</div>` : ''}
                    ${todo.deadline ? `
                        <div class="deadline-info">
                            <strong>Deadline:</strong> ${new Date(todo.deadline).toLocaleString('en-US', { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })}
                        </div>
                    ` : ''}
                    <div class="todo-actions">
                         <button class="action-btn edit-btn" aria-label="Edit task" data-id="${todo.id}">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="action-btn delete-btn" aria-label="Delete task" data-id="${todo.id}">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                `;
                todoList.appendChild(li);

                // Start countdown for tasks with deadlines that are not completed
                if (todo.deadline && !todo.completed) {
                     const countdownElement = li.querySelector('.countdown');
                     if (countdownElement) {
                         startCountdown(todo, countdownElement);
                     }
                }
            });

            updateTaskCounter();

            // Update active states for filters
            filterButtons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.filter === currentFilter) {
                    btn.classList.add('active');
                }
            });
        }

        function generateUniqueId() {
             return '_' + Math.random().toString(36).substr(2, 9);
        }

        function addTodo(title, description, priority, deadline) {
            const newTodo = {
                id: generateUniqueId(), // Assign a unique ID
                title: title,
                description: description,
                priority: priority,
                deadline: deadline || null, // Store deadline as string or null
                isCompleted: false, // Use isCompleted for consistency with data structure
                completed: false, // Keep 'completed' for existing logic compatibility
                completionDate: null,
                uiSettings: {
                    blockSize: "large"
                },
                notificationSettings: {
                    reminder24h: true,
                    reminderDeadline: true
                },
                messageTemplates: {
                    onTimeMotivation: "🎉 You nailed it with time to spare!", // Updated message
                    lateNotification: "⚠️ This task is now overdue—let’s get it done!"
                },
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                 // Flags to track if notifications have been sent for this task
                reminder24hSent: false,
                reminderDeadlineSent: false,
                lateNotificationSent: false
            };
            todos.push(newTodo);
            saveTodos();
            renderTodos();
        }

        function deleteTodo(id) {
            // Stop countdown before removing the task
            stopCountdown(id);
            todos = todos.filter(todo => todo.id !== id);
            saveTodos();
            renderTodos();
        }

        function toggleComplete(id) {
            const todo = todos.find(todo => todo.id === id);
            if (todo) {
                todo.completed = !todo.completed;
                 todo.isCompleted = todo.completed; // Keep in sync
                if (todo.completed) {
                    todo.completionDate = new Date().toISOString();
                    // Stop countdown when completed
                    stopCountdown(id);
                    // When marking as complete, reset late notification flag
                    todo.lateNotificationSent = false; // Reset if completed
                } else {
                    todo.completionDate = null;
                     // When marking as incomplete, reset reminder and late notification flags
                    todo.reminder24hSent = false;
                    todo.reminderDeadlineSent = false;
                    todo.lateNotificationSent = false; // Reset if marked incomplete
                    // Restart countdown if uncompleted and has a deadline
                    if(todo.deadline) {
                        const countdownElement = document.querySelector(`.countdown[data-id="${todo.id}"]`);
                        if(countdownElement) {
                             startCountdown(todo, countdownElement);
                        }
                    }
                }
                todo.updatedAt = new Date().toISOString();
                saveTodos();
                renderTodos();
            }
        }

        function editTodo(id, newTitle, newDescription) {
            const todo = todos.find(todo => todo.id === id);
            if (todo) {
                todo.title = newTitle.trim();
                todo.description = newDescription.trim();
                todo.updatedAt = new Date().toISOString();
                saveTodos();
                renderTodos();
            }
        }

        function clearCompleted() {
             // Stop countdowns for completed tasks before clearing
             todos.filter(todo => todo.completed).forEach(todo => stopCountdown(todo.id));
            todos = todos.filter(todo => !todo.completed);
            saveTodos();
            renderTodos();
        }

        todoForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const title = todoInput.value.trim();
            const description = todoDescriptionInput.value.trim();
            const priority = prioritySelect.value;
            const deadline = deadlineInput.value; // Get value from datetime-local input

            if (title) {
                addTodo(title, description, priority, deadline);
                todoInput.value = '';
                todoDescriptionInput.value = '';
                prioritySelect.value = 'low';
                deadlineInput.value = ''; // Clear deadline input
            }
        });

        todoList.addEventListener('click', (e) => {
            const target = e.target;
            const todoItem = target.closest('.todo-item');
            if (!todoItem) return;

            const id = todoItem.dataset.id;

            if (target.classList.contains('delete-btn') || target.closest('.delete-btn')) {
                deleteTodo(id);
            }

            if (target.classList.contains('edit-btn') || target.closest('.edit-btn')) {
                const todo = todos.find(t => t.id === id);
                 if (!todo) return;

                const todoTextElement = todoItem.querySelector('.todo-text');
                const taskDescriptionElement = todoItem.querySelector('.task-description');

                // Create input fields for editing
                const titleInput = document.createElement('input');
                titleInput.type = 'text';
                titleInput.value = todo.title;
                titleInput.classList.add('todo-input'); // Use existing style
                titleInput.style.flex = '1'; // Allow it to grow

                const descriptionTextarea = document.createElement('textarea');
                descriptionTextarea.value = todo.description || '';
                 descriptionTextarea.classList.add('todo-input'); // Use existing style
                 descriptionTextarea.style.flex = '1';
                 descriptionTextarea.placeholder = 'Edit description...';


                // Replace elements with inputs
                todoTextElement.replaceWith(titleInput);
                 if(taskDescriptionElement) {
                    taskDescriptionElement.replaceWith(descriptionTextarea);
                 } else {
                     // If no description existed, add the textarea below the title input
                     titleInput.parentElement.insertBefore(descriptionTextarea, titleInput.nextSibling);
                 }


                titleInput.focus(); // Focus the title input

                function handleEditEnd(titleInput, descriptionTextarea, id, originalTitleElement, originalDescriptionElement) {
                    const newTitle = titleInput.value.trim();
                    const newDescription = descriptionTextarea.value.trim();

                    if (newTitle) {
                        editTodo(id, newTitle, newDescription);
                    } else {
                        // If title is empty, revert to original elements
                        titleInput.replaceWith(originalTitleElement);
                         if(originalDescriptionElement) {
                             descriptionTextarea.replaceWith(originalDescriptionElement);
                         } else {
                             // If description was added during edit but left empty, remove the textarea
                             descriptionTextarea.remove();
                         }
                         // Re-render to restore click handlers etc.
                         renderTodos();
                    }
                }

                // Store original elements to revert if needed
                 const originalTitleElement = todoTextElement;
                 const originalDescriptionElement = taskDescriptionElement;


                // Add event listeners for blur and keyup (Enter/Escape)
                titleInput.addEventListener('blur', () => handleEditEnd(titleInput, descriptionTextarea, id, originalTitleElement, originalDescriptionElement));
                titleInput.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') {
                         // Prevent form submission if inside a form (though not in this case, good practice)
                         e.preventDefault();
                         handleEditEnd(titleInput, descriptionTextarea, id, originalTitleElement, originalDescriptionElement);
                    }
                    if (e.key === 'Escape') {
                         titleInput.replaceWith(originalTitleElement);
                          if(originalDescriptionElement) {
                             descriptionTextarea.replaceWith(originalDescriptionElement);
                         } else {
                             descriptionTextarea.remove();
                         }
                         renderTodos(); // Re-render to restore everything
                    }
                });

                 descriptionTextarea.addEventListener('blur', () => handleEditEnd(titleInput, descriptionTextarea, id, originalTitleElement, originalDescriptionElement));
                 descriptionTextarea.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) { // Allow Shift+Enter for new line
                         e.preventDefault();
                         handleEditEnd(titleInput, descriptionTextarea, id, originalTitleElement, originalDescriptionElement);
                    }
                    if (e.key === 'Escape') {
                         titleInput.replaceWith(originalTitleElement);
                          if(originalDescriptionElement) {
                             descriptionTextarea.replaceWith(originalDescriptionElement);
                         } else {
                             descriptionTextarea.remove();
                         }
                         renderTodos();
                    }
                 });
            }

            // Toggle complete when clicking the text or the item itself (excluding buttons)
            if (target.classList.contains('todo-text') || target.classList.contains('todo-item') || target.classList.contains('task-description') || target.classList.contains('deadline-info')) {
                // Ensure we don't toggle if clicking edit/delete buttons or their icons
                if (!target.closest('.action-btn')) {
                     toggleComplete(id);
                }
            }
        });

        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                currentFilter = button.dataset.filter;
                renderTodos();
            });
        });

        counterButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Extract filter from button ID (e.g., 'allCounter' -> 'all')
                const filter = button.id.replace('Counter', '').toLowerCase();
                currentFilter = filter === 'all' ? 'all' : filter; // Handle 'all' explicitly
                 if (filter === 'completed') currentFilter = 'completed'; // Handle completed counter
                renderTodos();
            });
        });

        clearCompletedBtn.addEventListener('click', () => {
            clearCompleted();
        });

        themeToggle.addEventListener('click', () => {
            currentTheme = currentTheme === 'light' ? 'dark' : 'light';
            document.documentElement.setAttribute('data-theme', currentTheme);
            themeToggle.innerHTML = currentTheme === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
            localStorage.setItem('theme', currentTheme);
        });

        // Drag-and-drop functionality
        let dragStartIndex = -1; // Use index within the *current* filtered list

        todoList.addEventListener('dragstart', (e) => {
            const targetItem = e.target.closest('.todo-item');
            if (!targetItem) return;

            // Find the index of the dragged item within the *currently filtered* list
            const filteredTodos = todos.filter(todo => {
                if (currentFilter === 'all') return true;
                if (currentFilter === 'completed') return todo.completed;
                return todo.priority === currentFilter;
            });
            dragStartIndex = filteredTodos.findIndex(todo => todo.id === targetItem.dataset.id);

            e.target.classList.add('dragging');
            // Set dataTransfer for drag operation (optional, but good practice)
            e.dataTransfer.setData('text/plain', targetItem.dataset.id);
        });

        todoList.addEventListener('dragend', (e) => {
            e.target.classList.remove('dragging');
            dragStartIndex = -1; // Reset drag start index
            // Re-render to ensure correct order and remove any drag artifacts
            renderTodos();
        });

        todoList.addEventListener('dragover', (e) => {
            e.preventDefault(); // Necessary to allow dropping
            const draggingItem = document.querySelector('.todo-item.dragging');
            if (!draggingItem) return;

            const afterElement = getDragAfterElement(todoList, e.clientY);

            if (afterElement == null) {
                todoList.appendChild(draggingItem);
            } else {
                todoList.insertBefore(draggingItem, afterElement);
            }
        });

         todoList.addEventListener('drop', (e) => {
            e.preventDefault(); // Necessary to allow dropping
            const draggedItemId = e.dataTransfer.getData('text/plain');
            const droppedOnItem = e.target.closest('.todo-item');
            const droppedOnItemId = droppedOnItem ? droppedOnItem.dataset.id : null;

            if (!draggedItemId) return;

            // Find the todo object being dragged
            const draggedTodo = todos.find(todo => todo.id === draggedItemId);
            if (!draggedTodo) return;

            // Remove the dragged todo from its original position
            todos = todos.filter(todo => todo.id !== draggedItemId);

            // Find the index to insert the dragged todo
            let insertIndex = todos.length; // Default to inserting at the end

            if (droppedOnItemId) {
                const droppedOnIndex = todos.findIndex(todo => todo.id === droppedOnItemId);
                if (droppedOnIndex !== -1) {
                    // Insert before the element we dropped on
                    insertIndex = droppedOnIndex;
                }
            }

            // Insert the dragged todo at the new position
            todos.splice(insertIndex, 0, draggedTodo);

            saveTodos();
            renderTodos(); // Re-render the list to reflect the new order
        });


        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.todo-item:not(.dragging)')];

            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) {
                    return { offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        // Initial render
        renderTodos();
        checkReminders(); // Check reminders on load
    </script>
</body>
</html>
